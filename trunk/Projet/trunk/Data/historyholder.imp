/*
 * Implementation file for history holders
 */

namespace Data {
    template<typename Type>
    HistoryHolder<Type>::HistoryHolder(Type t): _next(NULL), _t(t) {
        _first=this;
    }

    template<typename Type>
    HistoryHolder<Type>::~HistoryHolder(){
        while(!_toStore.isEmpty()){
            AutomatedStorage toDelete = _toStore.pop();
            if(toDelete.canBeDeleted){
                operator delete(toDelete.ptr);
            }
        }
    }

    template<typename Type>
    void HistoryHolder<Type>::pushInt(int data){
        AutomatedStorage toPush;
        toPush.canBeDeleted = false;
        toPush.ptr = (void*) data;
        toPush.size = 0;
        _toStore.push(toPush);
    }

    template<typename Type>
    template<typename PtrType>
    void HistoryHolder<Type>::pushPtr(PtrType * ptr){
        AutomatedStorage toPush;
        toPush.canBeDeleted = true;
        toPush.ptr = (void *) ptr;
        toPush.size = sizeof(PtrType);
        _toStore.push(toPush);
    }

    template<typename Type>
    void * HistoryHolder<Type>::pop(){
        if(!_toStore.isEmpty())
            return _toStore.pop().ptr;
        else
            return NULL;
    }

    template<typename Type>
    int HistoryHolder<Type>::getNumberOfStoredElements(){
        return _toStore.size();
    }

    template<typename Type>
    Type HistoryHolder<Type>::getType(){
        return _t;
    }

    template<typename Type>
    HistoryHolder<Type> * HistoryHolder<Type>::createNewAction(){
        HistoryHolder<Type> * hh = new HistoryHolder<Type>(_t);
        hh->setNextAction(this);
        hh->setFirst(_first);
        return hh;
    }

    template<typename Type>
    void HistoryHolder<Type>::setNextAction(HistoryHolder<Type> *next){
        _next = next;
    }

    template<typename Type>
    HistoryHolder<Type> * HistoryHolder<Type>::getNext(){
        return _next;
    }

    template<typename Type>
    HistoryHolder<Type> * HistoryHolder<Type>::getFirst(){
        return _first;
    }

    template<typename Type>
    void HistoryHolder<Type>::freeStructure(HistoryHolder<Type> * toFree){
        if(toFree != NULL){
            HistoryHolder<Type> * current = toFree;
            while(current!=NULL){
                HistoryHolder<Type> * next = current->getNext();
                delete current;
                current = next;
            }
        }
    }

    template<typename Type>
    void HistoryHolder<Type>::setFirst(HistoryHolder<Type>* first){
        _first = first;
    }

    template<typename Type>
    HistoryMaker<Type>::~HistoryMaker() {
        if(_makedHistory != NULL)
            HistoryHolder<Type>::freeStructure(_makedHistory);
    }

    template<typename Type>
    HistoryHolder<Type> * HistoryMaker<Type>::getCurrentHistoryHolder(Type t){
        if (_makedHistory == NULL)
            _makedHistory = new HistoryHolder<Type>(t);
        else
            _makedHistory = _makedHistory->createNewAction();

        return _makedHistory;
    }

    template<typename Type>
    HistoryCareTaker<Type>::~HistoryCareTaker() {
        // if historic are started but not ended we must stop them
        // in order to de-allocate them correctly
        foreach(Type key,_isStarted.keys())
            if(_isStarted[key])
                stopHistory(key);

        //de-allocation of all HistoryHolders.
        foreach(Type key,_passedHistory.keys())
            while(!_passedHistory.value(key)->isEmpty())
                HistoryHolder<Type>::freeStructure(_passedHistory.value(key)->pop());

        foreach(Type key,_futureHistory.keys())
            while(!_passedHistory.value(key)->isEmpty())
                HistoryHolder<Type>::freeStructure(_futureHistory.value(key)->pop());
    }

    template<typename Type>
    void HistoryCareTaker<Type>::undo(Type t){
        if(_passedHistory.contains(t))
            if(_passedHistory.value(t)->size()!=0){
                HistoryHolder<Type> * toUndo = (_passedHistory.value(t))->pop();
                HistoryHolder<Type> * globalHistory=NULL;
                foreach(HistoryMaker<Type> * hM, _historyMakers){
                    hM->startHistory(t);
                    hM->undo(toUndo);
                    HistoryHolder<Type> * localHistory;
                    if( (localHistory = hM->retrieveHistory(t)) != NULL){
                        if (globalHistory==NULL){
                            globalHistory = localHistory;
                        }else{
                            globalHistory->getFirst()->setNextAction(localHistory);
                        }
                    }
                }
                if(_futureHistory.contains(t)){
                    _futureHistory.value(t)->push_back(globalHistory);
                }else{
                    QStack<HistoryHolder<Type> *> * toFill = new QStack<HistoryHolder<Type> *>();
                    toFill->push(globalHistory);
                    _futureHistory.insert(t,toFill);
                }
            }
    }

    template<typename Type>
    void HistoryCareTaker<Type>::redo(Type t){
        if(_futureHistory.contains(t))
            if(_futureHistory.value(t)->size()!=0){
                HistoryHolder<Type> * toRedo = (_futureHistory.value(t))->pop();
                HistoryHolder<Type> * globalHistory=NULL;
                foreach(HistoryMaker<Type> * hM, _historyMakers){
                    hM->startHistory(t);
                    hM->undo(toRedo);
                    HistoryHolder<Type> * localHistory;
                    if( (localHistory = hM->retrieveHistory(t)) != NULL){
                        if (globalHistory==NULL){
                            globalHistory = localHistory;
                        }else{
                            globalHistory->getFirst()->setNextAction(localHistory);
                        }
                    }
                }
                if(_passedHistory.contains(t)){
                    _passedHistory.value(t)->push_back(globalHistory);
                }else{
                    QStack<HistoryHolder<Type> *> * toFill = new QStack<HistoryHolder<Type> *>();
                    toFill->push(globalHistory);
                    _passedHistory.insert(t,toFill);
                }
            }
    }

    template<typename Type>
    void HistoryCareTaker<Type>::addHistoryMaker(HistoryMaker<Type> * hM){
        _historyMakers.append(hM);
    }

    template<typename Type>
    int HistoryCareTaker<Type>::numberOfUndo(Type t){
        if(_passedHistory.contains(t))
            return _passedHistory.value(t)->size();
        else
            return 0;
    }

    template<typename Type>
    int HistoryCareTaker<Type>::numberOfRedo(Type t){
        if(_futureHistory.contains(t))
            return _futureHistory.value(t)->size();
        else
            return 0;
    }

    template<typename Type>
    void HistoryCareTaker<Type>::startHistory(Type t){

        if(_isStarted[t])
            return;

        _isStarted[t]=true;

        if(_futureHistory.contains(t)){
            _futureHistory.value(t)->clear();
        }

        foreach(HistoryMaker<Type> * hM, _historyMakers){
            hM->startHistory(t);
        }
    }

    template<typename Type>
    void HistoryCareTaker<Type>::stopHistory(Type t){

        if(!_isStarted[t])
            return;

        HistoryHolder<Type> * globalHistory = NULL;

        foreach(HistoryMaker<Type> * hM, _historyMakers){
            HistoryHolder<Type> * localHistory;
            if( (localHistory = hM->retrieveHistory(t)) != NULL){
                if (globalHistory==NULL){
                    globalHistory = localHistory;
                }else{
                    globalHistory->getFirst()->setNextAction(localHistory);
                }
            }
        }

        if(_passedHistory.contains(t)){
            _passedHistory.value(t)->push_back(globalHistory);
        }else{
            QStack<HistoryHolder<Type> *> * toFill = new QStack<HistoryHolder<Type> *>();
            toFill->push(globalHistory);
            _passedHistory.insert(t,toFill);
        }
        _isStarted[t] = false;
    }

}
